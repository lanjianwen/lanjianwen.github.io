<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[K-Means]]></title>
    <url>%2F2019%2F09%2F17%2FK-Means%2F</url>
    <content type="text"><![CDATA[K-means算法介绍 从D中随机取k个元素，作为k个簇的各自的中心。 分别计算剩下的元素到k个簇中心的相异度，将这些元素分别划归到相异度最低的簇。 根据聚类结果，重新计算k个簇各自的中心，计算方法是取簇中所有元素各自维度的算术平均数。 将D中全部元素按照新的中心重新聚类。 重复第4步，直到聚类结果不再变化。 将结果输出。JAVA代码实现分装Point类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package Kmeans;public class Point &#123; private float[] localArray; private int id; private int clusterId; // 标识属于哪个类中心。 private float dist; // 标识和所属类中心的距离。 public Point(int id, float[] localArray) &#123; this.id = id; this.localArray = localArray; &#125; public Point(float[] localArray) &#123; this.id = -1; //表示不属于任意一个类 this.localArray = localArray; &#125; public float[] getlocalArray() &#123; return localArray; &#125; public int getId() &#123; return id; &#125; public void setClusterId(int clusterId) &#123; this.clusterId = clusterId; &#125; public int getClusterid() &#123; return clusterId; &#125; public float getDist() &#123; return dist; &#125; public void setDist(float dist) &#123; this.dist = dist; &#125; @Override public String toString() &#123; String result = "Point_id=" + id + " ["; for (int i = 0; i &lt; localArray.length; i++) &#123; result += localArray[i] + " "; &#125; return result.trim()+"] clusterId: "+clusterId+" dist: "+dist; &#125; @Override public boolean equals(Object obj) &#123; if (obj == null || getClass() != obj.getClass()) return false; Point point = (Point) obj; if (point.localArray.length != localArray.length) return false; for (int i = 0; i &lt; localArray.length; i++) &#123; if (Float.compare(point.localArray[i], localArray[i]) != 0) &#123; return false; &#125; &#125; return true; &#125; @Override public int hashCode() &#123; float x = localArray[0]; float y = localArray[localArray.length - 1]; long temp = x != +0.0d ? Double.doubleToLongBits(x) : 0L; int result = (int) (temp ^ (temp &gt;&gt;&gt; 32)); temp = y != +0.0d ? Double.doubleToLongBits(y) : 0L; result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32)); return result; &#125;&#125; 封装Cluster123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package Kmeans;import java.util.ArrayList;import java.util.List; public class Cluster &#123; private int id;// 标识 private Point center;// 中心 private List&lt;Point&gt; members = new ArrayList&lt;Point&gt;();// 成员 public Cluster(int id, Point center) &#123; this.id = id; this.center = center; &#125; public Cluster(int id, Point center, List&lt;Point&gt; members) &#123; this.id = id; this.center = center; this.members = members; &#125; public void addPoint(Point newPoint) &#123; if (!members.contains(newPoint))&#123; members.add(newPoint); &#125;else&#123; System.out.println("样本数据点 &#123;"+newPoint.toString()+"&#125; 已经存在！"); &#125; &#125; public int getId() &#123; return id; &#125; public Point getCenter() &#123; return center; &#125; public void setCenter(Point center) &#123; this.center = center; &#125; public List&lt;Point&gt; getMembers() &#123; return members; &#125; @Override public String toString() &#123; String toString = "Cluster \n" + "Cluster_id=" + this.id + ", center:&#123;" + this.center.toString()+"&#125;"; for (Point point : members) &#123; toString+="\n"+point.toString(); &#125; return toString+"\n"; &#125;&#125; 求两个点的欧式距离12345678910111213141516171819202122package Kmeans;public class DistanceCompute &#123; /** * 求欧式距离 */ public double getEuclideanDis(Point p1, Point p2) &#123; double count_dis = 0; float[] p1_local_array = p1.getlocalArray(); float[] p2_local_array = p2.getlocalArray(); if (p1_local_array.length != p2_local_array.length) &#123; throw new IllegalArgumentException("length of array must be equal!"); &#125; for (int i = 0; i &lt; p1_local_array.length; i++) &#123; count_dis += Math.pow(p1_local_array[i] - p2_local_array[i], 2); &#125; return Math.sqrt(count_dis); &#125;&#125; 核心运行类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package Kmeans;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Random;import java.util.Set; public class KMeansRun &#123; private int kNum; //簇的个数 private int iterNum = 10; //迭代次数 private int iterMaxTimes = 100000; //单次迭代最大运行次数 private int iterRunTimes = 0; //单次迭代实际运行次数 private float disDiff = (float) 0.01; //单次迭代终止条件，两次运行中类中心的距离差 private List&lt;float[]&gt; original_data =null; //用于存放，原始数据集 private static List&lt;Point&gt; pointList = null; //用于存放，原始数据集所构建的点集 private DistanceCompute disC = new DistanceCompute(); private int len = 0; //用于记录每个数据点的维度 public KMeansRun(int k, List&lt;float[]&gt; original_data) &#123; this.kNum = k; this.original_data = original_data; this.len = original_data.get(0).length; //检查规范 check(); //初始化点集。 init(); &#125; /** * 检查规范 */ private void check() &#123; if (kNum == 0)&#123; throw new IllegalArgumentException("k must be the number &gt; 0"); &#125; if (original_data == null)&#123; throw new IllegalArgumentException("program can't get real data"); &#125; &#125; /** * 初始化数据集，把数组转化为Point类型。 */ private void init() &#123; pointList = new ArrayList&lt;Point&gt;(); for (int i = 0, j = original_data.size(); i &lt; j; i++)&#123; pointList.add(new Point(i, original_data.get(i))); &#125; &#125; /** * 随机选取中心点，构建成中心类。 */ private Set&lt;Cluster&gt; chooseCenterCluster() &#123; Set&lt;Cluster&gt; clusterSet = new HashSet&lt;Cluster&gt;(); Random random = new Random(); for (int id = 0; id &lt; kNum; ) &#123; Point point = pointList.get(random.nextInt(pointList.size())); // 用于标记是否已经选择过该数据。 boolean flag =true; for (Cluster cluster : clusterSet) &#123; if (cluster.getCenter().equals(point)) &#123; flag = false; &#125; &#125; // 如果随机选取的点没有被选中过，则生成一个cluster if (flag) &#123; Cluster cluster =new Cluster(id, point); clusterSet.add(cluster); id++; &#125; &#125; return clusterSet; &#125; /** * 为每个点分配一个类！ */ public void cluster(Set&lt;Cluster&gt; clusterSet)&#123; // 计算每个点到K个中心的距离，并且为每个点标记类别号 for (Point point : pointList) &#123; float min_dis = Integer.MAX_VALUE; for (Cluster cluster : clusterSet) &#123; float tmp_dis = (float) Math.min(disC.getEuclideanDis(point, cluster.getCenter()), min_dis); if (tmp_dis != min_dis) &#123; min_dis = tmp_dis; point.setClusterId(cluster.getId()); point.setDist(min_dis); &#125; &#125; &#125; // 新清除原来所有的类中成员。把所有的点，分别加入每个类别 for (Cluster cluster : clusterSet) &#123; cluster.getMembers().clear(); for (Point point : pointList) &#123; if (point.getClusterid()==cluster.getId()) &#123; cluster.addPoint(point); &#125; &#125; &#125; &#125; /** * 计算每个类的中心位置！ */ public boolean calculateCenter(Set&lt;Cluster&gt; clusterSet) &#123; boolean ifNeedIter = false; for (Cluster cluster : clusterSet) &#123; List&lt;Point&gt; point_list = cluster.getMembers(); float[] sumAll =new float[len]; // 所有点，对应各个维度进行求和 for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; point_list.size(); j++) &#123; sumAll[i] += point_list.get(j).getlocalArray()[i]; &#125; &#125; // 计算平均值 for (int i = 0; i &lt; sumAll.length; i++) &#123; sumAll[i] = (float) sumAll[i]/point_list.size(); &#125; // 计算两个新、旧中心的距离，如果任意一个类中心移动的距离大于dis_diff则继续迭代。 if(disC.getEuclideanDis(cluster.getCenter(), new Point(sumAll)) &gt; disDiff)&#123; ifNeedIter = true; &#125; // 设置新的类中心位置 cluster.setCenter(new Point(sumAll)); &#125; return ifNeedIter; &#125; /** * 运行 k-means */ public Set&lt;Cluster&gt; run() &#123; Set&lt;Cluster&gt; clusterSet= chooseCenterCluster(); boolean ifNeedIter = true; while (ifNeedIter) &#123; cluster(clusterSet); ifNeedIter = calculateCenter(clusterSet); iterRunTimes ++ ; &#125; return clusterSet; &#125; /** * 返回实际运行次数 */ public int getIterTimes() &#123; return iterRunTimes; &#125;&#125; 测试类123456789101112131415161718192021222324252627282930313233package Kmeans;import java.util.ArrayList;import java.util.Set; public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;float[]&gt; dataSet = new ArrayList&lt;float[]&gt;(); dataSet.add(new float[] &#123; 1, 2, 3 &#125;); dataSet.add(new float[] &#123; 3, 3, 3 &#125;); dataSet.add(new float[] &#123; 3, 4, 4&#125;); dataSet.add(new float[] &#123; 5, 6, 5&#125;); dataSet.add(new float[] &#123; 8, 9, 6&#125;); dataSet.add(new float[] &#123; 4, 5, 4&#125;); dataSet.add(new float[] &#123; 6, 4, 2&#125;); dataSet.add(new float[] &#123; 3, 9, 7&#125;); dataSet.add(new float[] &#123; 5, 9, 8&#125;); dataSet.add(new float[] &#123; 4, 2, 10&#125;); dataSet.add(new float[] &#123; 1, 9, 12&#125;); dataSet.add(new float[] &#123; 7, 8, 112&#125;); dataSet.add(new float[] &#123; 7, 8, 4&#125;); KMeansRun kRun =new KMeansRun(3, dataSet); Set&lt;Cluster&gt; clusterSet = kRun.run(); System.out.println("单次迭代运行次数："+kRun.getIterTimes()); for (Cluster cluster : clusterSet) &#123; System.out.println(cluster); &#125; &#125;&#125; 结果截图]]></content>
      <categories>
        <category>计算智能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
